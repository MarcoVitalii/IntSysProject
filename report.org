* Collaborative foraging using beacons, further developments

** Aim of the project
This project is inspired by the work done in [[http://cs.gmu.edu/~sean/papers/aamas10-beacons.pdf][Collaborative foraging using beacons]]. 
Once implemented the same algorithm in an obstacle free environment, this project will focus on the effects of 2 main changes:


1) A variation on the probability of deploying and removing beacons:
 The article states that to ensure a sparse beacons's network the maximum number of beacons deployable is set reasonably low. In this project this assumption is challenged 
proposing a new way to deploy beacons and regulate their number.
 In the original article new beacons are deployed with a constant probability pDeploy = 0.9 until maxBeaconNumber is reached. Once this threshold is reached,no more beacons can be deployed. 
 This poses two problems: first off, if maxBeaconNumber is too low, the initial exploration (done through deploying an irregular grid of beacons) can't cover enough surface of the environment to reach the food. Secondly,
 if the beacons's network is broken into disconnected pieces and maxBeaconNumber is reached with no accessible beacon that can be removed, the algorithm grinds to a halt.
 To ease this limitations a new pDeploy is proposed. It takes the functional form of  pDeploy(beaconsNumber) = exp(- beaconsNumber / maxBeaconNumber ).
 Such function allows to get over the threshold if it's set too low and allows the creation of new beacons at any time at a cost of an increasingly small probability
 of deployment. Then a second variation is introduced to solve the problem of getting stuck in local maxima. This issue arises once a region of the beacons's network is separated from 
 the rest of the connected part. Said region collapses on  it's local maximum and every new beacon deployed will be subsequently be removed as it is seen by the algorithm as obsolete( the maximum has the same
 neighborhood and has higher values of pheromones). The only way to get out of this situation is to hope that the network gets reconnected by ants which aren't trapped
 inside the maximum. The proposed solution works by taking into account a locality estimator called localityCount.It's defined as the time spent without changing the beacon chosen
 as best candidate inside canRemove. With probability  pRemove( localityCount ) = 1 - ( 1 - localityCount / \tau)^(0.2) the current beacon (referred as currBeacon inside the code) is removed even
 if it doesn't have the requirements for removal set by the original algorithm. This allows the removal of local maxima. If said maximum is the only beacon in its neighborhood, a new exploration will start with beacons with 0
 as pheromones value which can't be removed until they reconnect with the rest of the network.
2) The implementation of a finite beacon's lifetime.This setting reflects a more realistic environment where beacons are powered by batteries and their range decreases with time. A beacon timescale is introduced, that sets the period in which the beacon's range will decrease exponentially until
 a minumum range that, once reached, marks the end of the beacon's activity. The stability and performance of the algorithm will be tested at various values of beacon's timescale.

 
** Model's description
  The environment simulated is a bounded continuous field of size 100x100 in arbitrary units of length.
  Inside this field there's a fixed nest located at (10, 10) from the top left corner and 
  a fixed source of food located at (90, 90). The agents inside the model are ants that start the simulation at nest's position.
  At each timestep every agent follows the algorithm described in the previous article. For implementation reasons hole timesteps 
  are populated by ants's actions, half timesteps are populated by beacons's actions (they let the pheromones evaporate and, 
  if required, they shrink their range and deactivate themselfs if the end of their lifetime is reached).
  The desired collective behaviour is the emergence of an optimized path between food and nest 
  represented by a network of beacons which stores the values of pheromones used to guide the agent's movement.

As a general idea of what happens inside a typical simulation, few phases can be identified:


1) Searching phase: in the first part of the simulation the fact that every beacon has a 0 foraging pheromone allows them to be unremovable (as the condition of removal requires the presence of a beacon whose phermones values are strictly higher than the current beacon's ones), so the ants cover the map with an irregular grid of beacons until the system runs out of deployable beacons or food is found.
2) Reinforcing the best path: once food is found, ants start to get back to the nest, creating a sub-optimal path that will be optimized by straightening beacon's position through move actions or taking paths that have less beacons inside them
3) Eventually through the removal or movement of the beacons the network will be divided into disconnected parts. If the isolated beacon don't have any ant inside they are left on their own. If ants are trapped inside this disconnected network of beacons they can either  collapse the network on the local maximum or reconnect to the rest of the beacons, generating a new sub-optimal path between the food source and the nest.


The performances of the model are measured with this metrics:
1) Mean travel length : time needed to start from the nest and come back with food.
2) Food incoming rate: the ammount of food collected in an interval of 100 timesteps.
3) Total food recovered at a fixed time.
   
   
** Implementation of the model in MASON
  MASON provides a class SimState as core engine to develop simulations. Inside there's a scheduler 
  to handle agents's actions and a good random number generator to handle the stochastic side of the model.
  ForagingWithBeacons extends this class including all the Continuous2D fields needed to locate agents, beacons, 
  nest and food. All the key elements of the model are classes that implement the Steppable interface required by 
  the scheduler's methods. An ausiliary agent called statAgent is used to gather and print out all useful data about the simulation.


  A graphical interface is then developed through various portrayals located inside MASON libraries to see in real time the 
  model's behaviour, to change on the fly few key parameters. The rapresentation of every element of the simulation is inside "Running the simulation" chapter.
  
  
** Running the simulation
   Once downloaded MASON and the accessory libraries from [[https://cs.gmu.edu/%7Eeclab/projects/mason/#Download][the ufficial website]], follow their instructions to set correctly the CLASSPATH in your environment and add to it the path of your cloned repository of this project.
Compile all java classes inside the project and from here there are two options to run simulations.
There's a command line version that runs simulations as
#+BEGIN_SRC shell
java ForagingWithBeacons --time 100000 --until 100000 --repeat 10 --parallel 4
#+END_SRC
where various flags can control the number of simulations and their duration. If this code is used,
 inside ./data/ will be generated a settings.txt file containing all parameters's values and there'll 
be a file for every simulation with its seed as name. The following informations are stored every 100 timesteps:
| position | content          | position | content       | position | content          | position | content      |
|----------+------------------+----------+---------------+----------+------------------+----------+--------------|
|        1 | BeaconLifetime   |        6 | beaconsNumber |       11 | exploration      |       16 | wanderPh     |
|        2 | maxBeaconNumber  |        7 | avgPathLength |       12 | startExploration |       17 | randomMove   |
|        3 | time             |        8 | foundFood     |       13 | beaconMov        |       18 | foodPerAnt   |
|        4 | foodIncomingRate |        9 | foundHome     |       14 | followPh         |       19 | sqFoodPerAnt |
|        5 | foodRecovered    |       10 | beaconRem     |       15 | beaconDep        |       20 | seed         |
Fields from 8 to 18 are the distribution of actions taken by all ants.
FoodPerAnt and sqFoodPerAnt are the mean and the mean of the square of food recovered over the ants. The square is a measure of variance between single ants. 


A second version is launched with
#+BEGIN_SRC shell
java ForagingWithBeaconsUI
#+END_SRC
Here a graphical interface is created with a console that grants access to few relevant model's parameters and allows to start, pause and stop the simulation.
Every element of the simulation is clickable and inside the inspector panel few parameters are shown.


The graphical representation of every component of the model is as it follows:
- Beacons are represented as hexagons with a circle around them with the size of their range. The hexagon's color reflects the value of foraging pheromone while the outer circle's color reflects the value of ferrying pheromone. If the value of pheromones is 0 the hexagon or the outer circle is red as a visual cue to mark the fact that either the beacon is separated from the rest of the network or the propagation of foraging pheromone hasn't started yet(as no food has been found yet).
- Ants are dots and their color reflects their status: they are yellow if they  don't carry food or red if they do. 
- Nests are represented as magenta ovals.
- Food sources are cyan ovals.
  
  
** Beyond a fixed upper limit of deployable beacons
As previously stated, this first section has been developed to alleviate the problems that stop the agents from creating
 and optimizing the path between food and nest. The main focus is on the first and third phase descripted inside the "model description" chapter.
The first idea is to make sure that ants can deploy enough beacons to find the food, keeping a notion of upper limit of beacons 
deployable in a less strict sense.
The problem is shown here:

[[img/notEnoughBeacons.gif]]



The last frame captured shows a configuration of unconnected islands of beacons with ants stucked inside. The pheromone levels are distributed in such a way that there aren't beacons
removable and maxBeaconNumber is reached.
 By choosing pDeploy(beaconsNumber) = exp( - beaconsNumber / maxBeaconNumber ) is ensured that there's always a 
chace of deploying a new becon, but the probability of it happening drops very significantly as the number of current beacons deployed grows. Inside 
the simulations this variation of the algorithm will be identified with the "exp" label.


Using the same parameters as the previous simulation shown, once this new pDeploy is adopted, the algorithm is able to reach the objective:


[[img/notEnoughBeaconsExp.gif]]



A second variation is introduced to avoid of being stuck in local maxima. In the gif below is shown a simulation with 10 ants and a maxBeaconNumber = 30. 
This extreme condition is used to show clearly the impact of this variation of the algorithm.
This is the behaviour emergent from the "exp" variation (as the algorithm with pDeploy constant won't be able to reach the food).


[[img/stuckExp.gif]]


Once the food is reached, the connectedness of the beacon's network is broken into pieces and as time goes on all ants gets stuck in local maxima.



As widely discussed inside the "aim of the project " chapter, the probability of removing
a beacon even if it doesn't have the requirements set inside canRemove helps to mitigate this issue. The shape of the functional form of pRemove allows for a quite
good tollerance for increasingly high values of localityCount. This variation of the algorithm is labelled "expAndRem".


Here is a run of exactly the same simulation with this additional removal option. The frames of the gif refers to the same time inside the simulation.


[[img/stuckExpAndRem.gif]]


As the ants gets stuck inside local maxima, the dominant beacon is deleted. Signs of this behaviour are the red parts of the beacon's network, where the ants remained without a
beacon and started a new exploration ( similar to the exploration carried out at the beginning, but in this case also the ferrying pheromone is set to 0).


The performances of the article's model (labelled "const") and the two variations can be viewed in this gif: 
[[./img/diffMaxBeacon.gif]]


As predicted the "const" variation is not able to create a path between nest and food for values of maxBeaconNumber smaller than 100.
The other variations, on the other hand, allow a huge spike in the number of beacons deployed at the beginning of the simulation and then an equilibrium 
between pDeploy and the removal of beacons is reached. The effectiveness of evading local maxima through their deletion shines at low maxBeaconNumber as is 
very unlikely that other ants create a bridge to escape from local maxima.


As maxBeaconNumber grows bigger enough, the performance of the models reach the maximum. Once the path between food and nest is established, the algorithm regolates
the number of active beacons reaching an equilibrium that is the same for all models. The equilibrium that emerges from "expAndRem" at maxBeaconNumber = 100 shows
that peak performances in the food retrival (shown by the foodIncomeRate) can be achieved with less beacons, as this settings has, on average, around 100 beacons deployed
versus the average of 120 for bigger maxBeaconNumber values.
  


** Effects of beacon's lifetime on ants performances

In this section of the work a novelty is introduced: beacons  now have a lifetime definded by the variable beaconTimescale. Whithin such lifetime their range shrinks 
exponentially until it reaches half of the original radius. At this point they shut themselfs down. The ants behaviour has been modified to accomodate this changes.
In particular the relation of neighborhood is not trivial and has been altered. Now currBeacon's neighborhood is composed by beacons whose distance is less than the minimum range between
their current range and currBeacon's one. This requirements allows the propagation of pheromones updates as it's expected. In fact, without this new definition of neighborhood, it's not guaranteed
that an ant can update pheromones levels with the values of its previous position as being neighbors isn't a symmetric relation ( as beacon's ranges aren't necessary equal).


Once addressed this problems, 60 simulations for every chosen beaconTimescale were executed, outputting the following results:


[[beaconTimescalePerformance.svg]]


As reported in this graphs, peformances aren't affected by beacon's lifetime if it is much higher than the mean time necessary
 to reach and bring back food ( which is a sort of a temporal path length and will be referred as pathLength). 
Once this timescale reaches the same order of magnitude of the pathLength, performaces start to cap at a maximum equal to the level reached without a finite beacon's lifetime.
As reported in the graph on the right, the mean incoming food rate decreases almost exponentially between 4 and 64. After 64, performances
grow sub-exponentially up to the peak of the previously discussed model. 


With beaconTimeScale = 0 is reported the performance of ants moving at random unless there's the nest or the food source in range. The extra complexity
 needed to deploy and maintain a beacon's network pays off at timescales bigger than 4, which is an extreme case as the mean travelLength at peak performaces 
is around 90/100 timesteps. As more and more of the sub-optimal path can be maintained active, performances grow exponentially. At beaconTimescale = 16 the full
path emerges as a macroscopic behaviour. From here to the highest scales the fraction of time dedicated to maintenance drops, favouring the behaviour of following the phermones trail
as reported in the mean distribution of actions taken by the ants:


[[beaconTimescaleActions.svg]]



** Conclusions

As shown with the simulation's results, the number of deployed beacons reaches an equilibrium between the rate of deployment and removal once the first ant reaches 
the food source. Limitations on this number as a hard limit damages the perfomances if set to low as this first exploration phase won't be completed.
The proposed pDeploy is able to lower the number of beacons deployed once the equilibrium has been reached at the cost of reducing also the performances. 
The proposed removal of local maxima is an effective way to deal with them in the condition of a low density system, where the probability of getting reached 
by the rest of the network is low.



When a finite beacon's lifetime is considered, the algorithm is robust showing better performances than random moves  even at extremely low timescales, and its performances
aren't affected significantly if this timescale exceedes the order of magnitude of the typical time needed to take the food and bring it back.


Future developments can explore the flexibility of the suboptimal path in a finite beacon's lifetime where the food source isn't fixed in a location. The heavy maintenance of the
suboptimal path might increase its ability to follow the food source.
